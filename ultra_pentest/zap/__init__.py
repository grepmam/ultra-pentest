# The MIT License (MIT)
#
# Copyright (c) 2024 Marco Martel
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import os
import time
import subprocess

import requests
from requests.exceptions import RequestException
from zapv2 import ZAPv2

from ultra_pentest.zap.components.context import Context
from ultra_pentest.zap.components.authentication import Authentication
from ultra_pentest.zap.components.user import User
from ultra_pentest.zap.components.session_management import SessionManagement
from ultra_pentest.zap.components.passive_scan import PassiveScan
from ultra_pentest.zap.components.spider import Spider
from ultra_pentest.zap.components.active_scan import ActiveScan
from ultra_pentest.zap.components.report import Report
from ultra_pentest.zap.components.session import Session
from ultra_pentest.zap.exceptions import ZAPError


class ZAPManager:

    def __init__(
        self,
        zap_executable: str,
        zap_url: str,
        zap_port: int,
        zap_log: str,
    ) -> None:
        self._executable = zap_executable

        self._proxy_url = f'{zap_url}:{zap_port}'
        self._port = zap_port
        self._log_file = zap_log
        self._config = None

        self._zap = ZAPv2(
            proxies={
                'http': self._proxy_url,
                'https': self._proxy_url,
            },
        )

        self._context = Context(zap=self._zap)
        self._authentication = Authentication(zap=self._zap)
        self._user = User(zap=self._zap)
        self._session_management = SessionManagement(zap=self._zap)
        self._passive_scan = PassiveScan(zap=self._zap)
        self._spider = Spider(zap=self._zap)
        self._active_scan = ActiveScan(zap=self._zap)
        self._report = Report(zap=self._zap)
        self._session = Session(zap=self._zap)

    @property
    def context(self) -> Context:
        return self._context

    @property
    def authentication(self) -> Authentication:
        return self._authentication

    @property
    def user(self) -> User:
        return self._user

    @property
    def session_management(self) -> SessionManagement:
        return self._session_management

    @property
    def passive_scan(self) -> PassiveScan:
        return self._passive_scan

    @property
    def spider(self) -> Spider:
        return self._spider

    @property
    def active_scan(self) -> ActiveScan:
        return self._active_scan

    @property
    def report(self) -> Report:
        return self._report

    @property
    def session(self) -> Session:
        return self._session
    
    def start(self) -> None:
        zap_command = [
            self._executable,
            '-daemon',
            '-port',
            str(self._port),
            '-config',
            'api.disablekey=true',
        ]

        with open(self._log_file, 'w+') as log_file:
            subprocess.Popen(
                zap_command,
                cwd=os.path.dirname(self._executable),
                stdout=log_file,
                stderr=subprocess.STDOUT
            )

        self._wait_for_zap()

    def shutdown(self) -> None:
        self._zap.core.shutdown()
        self._wait_for_zap()

    def _wait_for_zap(self) -> None:
        timeout_time = time.time() + 60
        while not self.is_running():
            if time.time() > timeout_time:
                raise ZAPError('[x] Timed out waiting for ZAP.')
            time.sleep(2)

    def is_running(self) -> bool:
        try:
            result = requests.get(self._proxy_url)
        except RequestException:
            return False

        if 'ZAP-Header' not in result.headers.get('Access-Control-Allow-Headers', []):
            raise ZAPError('[x] Another process is listening on {0}'.format(self._proxy_url))

        return True

    def open_url(self, url: str) -> None:
        self._zap.urlopen(url)
        time.sleep(3)